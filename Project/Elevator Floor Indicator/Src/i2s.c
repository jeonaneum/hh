
#include <stdio.h>
#include <string.h>

#include "NUC1xx.h"
#include "DrvSYS.h"
#include "DrvGPIO.h"
#include "DrvI2S.h"

#include "common.h"
#include "main.h"

#include "i2s.h"
#include "uart.h"

#ifdef _USE_I2S_

u08 i2s_out = OFF;
u08 i2s_data_cnt = 0;

#define SINE_CODE_MAX	96
/*
//SampleRate:48kHz, Frequency:1000Hz, Level:0dBFS
const u32 sine_wave[SINE_CODE_MAX] = {
	0x00000000,0x08580000,0x10B00000,0x18E30000,0x21170000,0x29020000,0x30ED0000,0x386D0000,0x3FED0000,0x46ED0000,0x4DD40000,0x541D0000,
	0x5A670000,0x5FEA0000,0x656E0000,0x6A130000,0x6EB80000,0x726B0000,0x761E0000,0x78CE0000,0x7B7E0000,0x7D1F0000,0x7EC10000,0x7F4D0000,
	0x7FD90000,0x7F4D0000,0x7EC10000,0x7D1F0000,0x7B7E0000,0x78CE0000,0x761E0000,0x726B0000,0x6EB80000,0x6A130000,0x656E0000,0x5FEA0000,
	0x5A670000,0x541D0000,0x4DD40000,0x46ED0000,0x3FED0000,0x386D0000,0x30ED0000,0x29020000,0x21170000,0x18E30000,0x10B00000,0x08580000,
	0x00000000,0xF7A80000,0xEF500000,0xE71C0000,0xDEE90000,0xD6FE0000,0xCF130000,0xC7930000,0xC0130000,0xB91F0000,0xB22C0000,0xABE20000,
	0xA5990000,0xA0150000,0x9A920000,0x95ED0000,0x91480000,0x8D950000,0x89E20000,0x87320000,0x84820000,0x82E00000,0x813F0000,0x80B30000,
	0x80270000,0x80B30000,0x813F0000,0x82E00000,0x84820000,0x87320000,0x89E20000,0x8D950000,0x91480000,0x95ED0000,0x9A920000,0xA0150000,
	0xA5990000,0xABE20000,0xB22C0000,0xB91F0000,0xC0130000,0xC7930000,0xCF130000,0xD6FE0000,0xDEE90000,0xE71C0000,0xEF500000,0xF7A80000,
};
*/
//SampleRate:48kHz, Frequency:1000Hz, Level:-20dBFS
const u32 sine_wave[SINE_CODE_MAX] = {
	0x00000000,0x00D50000,0x01AB0000,0x027D0000,0x034F0000,0x04190000,0x04E40000,0x05A40000,0x06640000,0x07160000,0x07C80000,0x08690000,
	0x090A0000,0x09970000,0x0A250000,0x0A9B0000,0x0B120000,0x0B710000,0x0BD00000,0x0C140000,0x0C590000,0x0C830000,0x0CAD0000,0x0CBB0000,
	0x0CC90000,0x0CBB0000,0x0CAD0000,0x0C830000,0x0C590000,0x0C140000,0x0BD00000,0x0B710000,0x0B120000,0x0A9B0000,0x0A250000,0x09970000,
	0x090A0000,0x08690000,0x07C80000,0x07160000,0x06640000,0x05A40000,0x04E40000,0x04190000,0x034F0000,0x027D0000,0x01AB0000,0x00D50000, 
	0x00000000,0xFF2A0000,0xFE550000,0xFD830000,0xFCB10000,0xFBE60000,0xFB1C0000,0xFA5C0000,0xF99C0000,0xF8EA0000,0xF8380000,0xF7970000,
	0xF6F60000,0xF6680000,0xF5DB0000,0xF5640000,0xF4EE0000,0xF48F0000,0xF4300000,0xF3EB0000,0xF3A70000,0xF37D0000,0xF3530000,0xF3450000,
	0xF3370000,0xF3450000,0xF3530000,0xF37D0000,0xF3A70000,0xF3EB0000,0xF4300000,0xF48F0000,0xF4EE0000,0xF5640000,0xF5DB0000,0xF6680000,
	0xF6F60000,0xF7970000,0xF8380000,0xF8EA0000,0xF99C0000,0xFA5C0000,0xFBE60000,0xFB1C0000,0xFD830000,0xFCB10000,0xFE550000,0xFF2A0000, 
};

void I2S_IRQHandler(void)
{
	if(I2S->I2SSTATUS.I2STXINT == 1)
	{
		// Tx underflow
		if((I2S->I2SSTATUS.TXUDF == 1) && (I2S->I2SIE.TXUDFIE == 1))
		{
			I2S->I2SSTATUS.TXUDF = 1;
		}
		// Tx overflow
		if((I2S->I2SSTATUS.TXOVF == 1) && (I2S->I2SIE.TXOVFIE == 1))
		{
			I2S->I2SSTATUS.TXOVF = 1;
		}
		// Tx right zero cross
//		if((I2S->I2SSTATUS.RZCF == 1) && (I2S->I2SIE.RZCIE == 1))
//		{
//			I2S->I2SSTATUS.RZCF = 1;
//		}
		// Tx left zero cross
//		if((I2S->I2SSTATUS.LZCF == 1) && (I2S->I2SIE.LZCIE == 1))
//		{
//			I2S->I2SSTATUS.LZCF = 1;
//		}   
		// Tx threshold level
		if(I2S->I2SIE.TXTHIE == 1)
		{
			u32 u32Len, i;

			u32Len = 8 - _DRVI2S_READ_TX_FIFO_LEVEL();	// Read Tx FIFO free size
			
			for(i=0; i<u32Len/2; i+=2){
			//	_DRVI2S_WRITE_TX_FIFO(sine_wave[i2s_data_cnt]);
			//	_DRVI2S_WRITE_TX_FIFO(sine_wave[i2s_data_cnt]);
				_DRVI2S_WRITE_TX_FIFO(0);
				_DRVI2S_WRITE_TX_FIFO(0);
				i2s_data_cnt += 2;
				if(i2s_data_cnt >= SINE_CODE_MAX)	i2s_data_cnt = 0;
			}
		}
	}
	else if(I2S->I2SSTATUS.I2SRXINT == 1)
	{
		// Rx underflow
		if((I2S->I2SSTATUS.RXUDF) && (I2S->I2SIE.RXUDFIE == 1))
		{
			I2S->I2SSTATUS.RXUDF = 1;  
		}
		// Rx overflow
		else if((I2S->I2SSTATUS.RXOVF) && (I2S->I2SIE.RXOVFIE == 1))
		{
			I2S->I2SSTATUS.RXOVF = 1;    
		}
		// Rx threshold level
		else if(I2S->I2SIE.RXTHIE == 1)
		{
		}   
	}   
}

void I2S_Init(void)
{
	S_DRVI2S_DATA_T st;
	
	DrvGPIO_Open(E_GPC, 0, E_IO_OPENDRAIN);		// Tri-state for FS and BCLK
	DrvGPIO_Open(E_GPC, 1, E_IO_OPENDRAIN);
	DrvGPIO_SetBit(E_GPC, 0);
	DrvGPIO_SetBit(E_GPC, 1);

	DrvGPIO_InitFunction(E_FUNC_I2S);			// Set I2S I/O
	
//#define DRVI2S_EXT_12M        0
//#define DRVI2S_PLL            1
//#define DRVI2S_HCLK           2
//#define DRVI2S_INTERNAL_22M   3
	DrvSYS_SelectIPClockSource(E_SYS_I2S_CLKSRC, 0);	// Select I2S Clock Source
	
	st.u32SampleRate     = 48000UL;
	st.u8WordWidth       = DRVI2S_DATABIT_32;
	st.u8AudioFormat     = DRVI2S_STEREO;
	st.u8DataFormat      = DRVI2S_FORMAT_I2S;
	st.u8Mode            = DRVI2S_MODE_MASTER;
	st.u8TxFIFOThreshold = DRVI2S_FIFO_LEVEL_WORD_2;
	st.u8RxFIFOThreshold = DRVI2S_FIFO_LEVEL_WORD_8;
	    
	DrvI2S_Open(&st);
	
	DrvI2S_SetMCLKFreq(6144000UL);				// Set MCLK and enable MCLK
#ifdef _DEBUG_
	printf("MCLK %d\n", DrvI2S_GetMCLKFreq());
#endif
//	DrvI2S_EnableMCLK();
	
//	NVIC_SetPriority(I2S_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
//	NVIC_EnableIRQ(I2S_IRQn);

//	I2S->I2SIE.RXTHIE = 1;
//	I2S->I2SCON.RXEN = 1;
//	I2S->I2SIE.TXTHIE = 1;
	I2S->I2SCON.TXEN = 0;
	I2S->I2SCON.MCLKEN = 0;
	I2S->I2SCON.I2SEN = 0;
	i2s_data_cnt = 0;
}

void I2S_Out(u08 onoff)
{
	if(i2s_out != onoff)
	{
		i2s_out = onoff;

		#ifdef _DEBUG_
		printf("Audio %s\n", (onoff?"ON":"OFF"));
		#endif
	
		if(onoff){
		//	I2S->I2SIE.TXTHIE = 1;
			I2S->I2SCON.TXEN = 1;
			I2S->I2SCON.MCLKEN = 1;
			I2S->I2SCON.I2SEN = 1;
		}
		else{
		//	I2S->I2SIE.TXTHIE = 0;
			I2S->I2SCON.TXEN = 0;
			I2S->I2SCON.MCLKEN = 0;
			I2S->I2SCON.I2SEN = 0;
			i2s_data_cnt = 0;
		}
	}
}

#endif
